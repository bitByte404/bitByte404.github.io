<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试页面2</title>
      <link href="/2024/08/18/%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A22/"/>
      <url>/2024/08/18/%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A22/</url>
      
        <content type="html"><![CDATA[<h1 id="注解反射和动态代理"><a href="#注解反射和动态代理" class="headerlink" title="注解反射和动态代理"></a>注解反射和动态代理</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p><strong>注解的作用或者意义是什么？</strong></p><p> 注解本身没有任何含义，单独的注解就是一种或注解，它需要结合其他如反射、插桩等技术才有意义</p><p>Java注解(Annotation)又称Java标注，是JDK1.5引入的一种注解机制。是元数据的一种形式，提供关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有用直接影响</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用<code>@interface</code>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.ROUTIME)</span> <span class="comment">//保留时</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span> <span class="comment">//作用目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Lance &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>在定义注解时，注解类也能够使用其他的注解声明。在JDK1.5中提供了**用来对注解类进行注解的注解类，我们称之为meta-annotation(元注解)**。</p><p>声明的注解允许作用于哪些节点使用**<code>@Target</code>**声明：</p><ul><li><code>TYPE</code></li><li><code>FIELD</code></li><li><code>METHOD</code></li><li><code>PARAMETER</code></li><li><code>CONSTRUCTOR</code></li><li><code>LOCAL_VARIABLE</code></li><li><code>ANNOTATION_TYPE</code></li><li><code>PACKAGE</code></li><li><code>TYPE_PARAMETER</code></li><li><code>TYPE_USE</code></li><li><code>MODULE</code></li><li><code>RECORD_COMPONENT</code></li></ul><p>保留级别有**<code>@Retention</code>**声明。其中保留级别如下</p><ul><li><p><code>RetentionPolicy.SOURCE</code></p><p>标记的注解仅保留在源级别，并被编译器忽略</p></li><li><p><code>RetentionPolicy.CLASS</code></p><p>标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略 </p></li><li><p><code>Retention.RUNTIME</code></p><p>标记的注解由JVM保留，因此运行时环境可以使用它</p></li></ul><p>SOURCE&lt;CLASS&lt;ROUTIME, 即CLASS包含了SOURCE， ROUTIME包含SOURCE、CLASS&gt;</p><p><strong>注意：</strong> </p><p><strong>CLASS级别的注解保留到class，会被jvm抛弃，但在Android中运行的是dex、class级别注解会被抛弃，runtime注解也和Java一样，被虚拟机识别解析</strong> </p><p>实际应用场景</p><h3 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h3><p>根据注解的保留级别不同，对注解的使用自然存在不同场景。<strong>由注解的三个不同保留级别可知，注解作用于：源码、字节码、运行时，以下是一些案例</strong></p><table><thead><tr><th>级别</th><th>技术</th><th>使用场景</th></tr></thead><tbody><tr><td>源码</td><td>APT</td><td>在编译期能够获取注解与注解声明的类包括类中所有成员的信息，一般用于生成额外的辅助类</td></tr><tr><td>字节码</td><td>字节码增强</td><td>在编译出Class后，通过修改Class数据以实现修改代码逻辑目的。对于是否需要修改的区分或者修改为不同逻辑的判断可以使用注解</td></tr><tr><td>运行时</td><td>反射</td><td>在程序运行期间，通过反射技术动态或者注解与其元素，从而完成不同的逻辑判定</td></tr></tbody></table><h6 id="限制参数取值范围"><a href="#限制参数取值范围" class="headerlink" title="限制参数取值范围"></a>限制参数取值范围</h6><p>使用枚举的缺点：每个值都会编译成一个对象(对象占用内存运算：对象头 + 实际数据 + 对齐)，更耗内存</p><p>自定义注解：又可以节省内存，又可以限制入参</p><h2 id="APT注解处理器"><a href="#APT注解处理器" class="headerlink" title="APT注解处理器"></a>APT注解处理器</h2><p>(annotation processor tools)注解处理器</p><p><strong>注意：</strong></p><ul><li><p>常用的第三方库中应用：glide arouter butterknife ann hilt…</p></li><li><p><code>-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...]</code> </p><p>要运行的注释处理程序的名称; 绕过默认的搜索进程</p></li><li><p><code>javac -procerssor apt.jar xxx.java</code> </p><p>apt其实就可以看成javac的一个插件</p></li><li><p><code>-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...]</code> </p><p>要运行的注释处理程序的名称; 绕过默认的搜索进程</p></li><li><p>apt：不会打包进入APK，只会在编译时参与编译</p></li></ul><h5 id="自己实现APT"><a href="#自己实现APT" class="headerlink" title="自己实现APT"></a>自己实现APT</h5><p>创建模块</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104140619388.png" alt="image-20231104140619388"></p><p>添加依赖</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104140701415.png" alt="image-20231104140701415"></p><p>注意：创建的是Java模块，而不是Android模块，Android模块不能给Java模块依赖</p><h6 id="创建注解类"><a href="#创建注解类" class="headerlink" title="创建注解类"></a>创建注解类</h6><p>在annotation模块中创建注解：</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104140852713.png" alt="image-20231104140852713"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建实现类"><a href="#创建实现类" class="headerlink" title="创建实现类"></a>创建实现类</h6><p>在compile模块下创建注解处理器的实现类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessor</span> <span class="title">extends</span> <span class="title">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean process(Set&lt;? extends TypeElement&gt; <span class="keyword">set</span>, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>process</code>方法，由javac调用，写什么代码就做什么事情</p><h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><ul><li><p>在compile模块的main文件夹下创建：resource -&gt; META-INF -&gt; services -&gt; javax.annotation.prrocessing.Processor中进行注册</p></li><li><p>写上APT实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.wuliner.compile.TestProcessor</span><br></pre></td></tr></table></figure></li></ul><h6 id="配置允许APT处理的注解"><a href="#配置允许APT处理的注解" class="headerlink" title="配置允许APT处理的注解"></a>配置允许APT处理的注解</h6><p>以下两种方法选一种就可以了</p><ul><li>重写该实现类的<code>getSuppotedAnnotationTypes</code>方法</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许此注解处理器处理的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>@SupportedAnnotationTypes()注解</code></p><p>括号中写注解类的全类名,如<code>@SupportedAnnotationTypes(&#123;&quot;com.wuliner.annotation.MyClass&quot;&#125;)</code></p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;<span class="string">&quot;com.wuliner.annotation.MyClass&quot;</span>&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CwProcessor</span> <span class="title">extends</span> <span class="title">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean process(Set&lt;? extends TypeElement&gt; <span class="keyword">set</span>, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Messager messager = processingEnv.getMessager();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;=========&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="引入APT所在模块"><a href="#引入APT所在模块" class="headerlink" title="引入APT所在模块"></a>引入APT所在模块</h6><p>在<code>build.gradle</code></p><ul><li><p><strong>Java</strong>中使用<code>annotationProcessor</code>，如<code>annotationProcessor project(&#39;compiler&#39;)</code></p></li><li><p><strong>kolin</strong>中使用kapt</p></li></ul><p><strong>注意：</strong>apt不会打包进入APK，只会在编译时参与编译</p><h6 id="APT的使用"><a href="#APT的使用" class="headerlink" title="APT的使用"></a>APT的使用</h6><ol><li><p>在类名前添加注解，如<code>@MyClass</code></p></li><li><p>在Processor实现类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;&quot;com.wuliner.annotation.MyClass&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CwProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * javac 调用此方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnvironment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;</span><br><span class="line">        <span class="comment">//写什么代码就做什么事情</span></span><br><span class="line">        <span class="comment">//process：javac编译时的一个回调</span></span><br><span class="line">        <span class="type">Messager</span> <span class="variable">messager</span> <span class="operator">=</span> processingEnv.getMessager();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;=========&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许此注解处理器处理的注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span></span><br><span class="line"><span class="comment">//        return super.getSupportedAnnotationTypes();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><strong>使用Message打印日志：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Messager</span> <span class="variable">messager</span> <span class="operator">=</span> processingEnv.getMessager();</span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line">messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;=========&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="引入注解模块"><a href="#引入注解模块" class="headerlink" title="引入注解模块"></a>引入注解模块</h5><p>使用<code>annotationProcessor</code>引入注解处理器模块, 若使用kotlin，则使用<code>kapt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotationProcessor(project(<span class="string">&quot;:compile&quot;</span>))</span><br></pre></td></tr></table></figure><p>apt不会打包进入apk，只会在编译时参与编译</p><p>在Build窗口中查看日志</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20230911091721939.png" alt="image-20230911091721939"></p><h5 id="为什么APT中process方法会执行多次？"><a href="#为什么APT中process方法会执行多次？" class="headerlink" title="为什么APT中process方法会执行多次？"></a>为什么APT中process方法会执行多次？</h5><p>Java将源码编译成class文件的过程：</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104151347259.png" alt="Java将源码编译为class文件的过程"></p><p>java编译过程:词法分析、语法分析、填充符号表、注解处理器处理注解、语义分析、解语法糖、生成字节码。</p><p>注解处理器可以增删改抽象语法树的任意元素。执行到注解处理器，都会重新执行词法分析、语法分析、填充符号表步，直到注解处理器不再对语法树进行修改为止，每一次的循环过程都称为一次Round。</p><p>process第一个参数set集合是要处理的注解集合，如果这个集合为null了，就不需要处理了。写代码就这样去做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!set.isEmpty())&#123;</span><br><span class="line"><span class="comment">//…执行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者通过<code>roundEnvironment.processingOver()</code>将round结束</p></li></ol><h2 id="字节码增强-插桩"><a href="#字节码增强-插桩" class="headerlink" title="字节码增强(插桩)"></a>字节码增强(插桩)</h2><p>字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。</p><p>此外，我们平时使用的动态代理、AOP也于字节码增强密切相关，它们实质上还是利用各种手段生成或修改符合规范的字节码文件。</p><p>综上所述，掌握字节码增强后可以高效的定位并快速修复一些棘手的问题(如线上性能问题，方法出现不可控的出入参需要紧急加日志等问题),也可以在开发中减少冗余代码，大大提高开发效率</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射实现findViewById"><a href="#反射实现findViewById" class="headerlink" title="反射实现findViewById"></a>反射实现<code>findViewById</code></h3><h5 id="通过反射获取类的成员"><a href="#通过反射获取类的成员" class="headerlink" title="通过反射获取类的成员"></a>通过反射获取类的成员</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">injectView</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; cls = acctivity.getClass();</span><br><span class="line">  <span class="comment">//获得此类所有的成员</span></span><br><span class="line">  Filed[] declaredFields = cls.getDeclaredFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><code>Filed</code></p><p>获得自己+父类的成员(不包括private，只能是public)</p></li><li><p><code>DecleredFile</code></p><p>只能获得自己的成员(不包括父类,所有作用域)</p></li></ul><p>可以通过<code>getSuperClass()</code>获取父类的class文件</p><h5 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h5><p>创建注解用来标识，用于筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectView &#123;</span><br><span class="line">  <span class="meta">@IdRes</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要标识的属性上使用注解</p><p>这一传入了<code>TextView</code>对应的id，用来实现<code>findViewById</code>的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectView(R.id.tv)</span></span><br><span class="line"><span class="keyword">private</span> TextView tv;</span><br></pre></td></tr></table></figure><h5 id="筛选Field"><a href="#筛选Field" class="headerlink" title="筛选Field"></a>筛选Field</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InjectUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">injectView</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; cls = activity.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得此类所有的成员</span></span><br><span class="line">        Field[] declaredFields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field filed : declaredFields) &#123;</span><br><span class="line">            <span class="comment">// 判断属性是否被InjectView注解声明</span></span><br><span class="line">            <span class="keyword">if</span> (filed.isAnnotationPresent(InjectView.class)) &#123;</span><br><span class="line">                <span class="type">InjectView</span> <span class="variable">injectView</span> <span class="operator">=</span> filed.getAnnotation(InjectView.class);</span><br><span class="line">                <span class="comment">//获得了注解中设置的id</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> injectView.value();</span><br><span class="line">                <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> activity.findViewById(id);</span><br><span class="line">                <span class="comment">//反射设置 属性的值</span></span><br><span class="line">                filed.setAccessible(<span class="literal">true</span>); <span class="comment">//设置访问权限，允许操作private的属性</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//反射赋值</span></span><br><span class="line">                    filed.set(activity, view);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>先通过<code>Filed</code>的<code>isAnnotationPresent()</code>方法，传入自定义注解的class文件用来判断属性是否被InjectView注解声明</p></li><li><p>再通过<code>getAnnotation()</code>方法，传入注解的class文件，获得对应的注解类</p></li><li><p>再通过这个类获取对应的属性，获得注解中设置的id后，获取对应的View</p></li><li><p>然后通过反射设置属性的值</p><p>先用<code>filed.setAccessible(true)</code>设置访问权限，允许操作private的属性</p><p>通过<code>filed.set(activity, view)</code>，将TextView值设置为对应的View</p></li></ul><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231118140800129.png" alt="image-20231118140800129" style="zoom:80%;" /><h3 id="通过反射获取泛型的真实类型"><a href="#通过反射获取泛型的真实类型" class="headerlink" title="通过反射获取泛型的真实类型"></a>通过反射获取泛型的真实类型</h3><h4 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h4><ul><li><p><code>TypeVariable</code></p><p>泛型类型变量。可以泛型上下限等信息</p></li><li><p><code>ParameterType</code></p><p>具体的泛型类型，可以获得元数据中泛型签名类型(泛型真实类型)</p></li><li><p><code>GenericArrayType</code></p><p>当需要描述的类型是泛型类的数据时，比如List[],Map[],此接口会作为Type的实现</p></li><li><p><code>WildcardType</code></p><p>通配符泛型，获得上下限信息</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeRefrence</span>&lt;Response&lt;Data&gt;&gt;().getType(); <span class="comment">//不行正常运行</span></span><br><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeRefrence</span>&lt;Response&lt;Data&gt;&gt;()&#123;&#125;.getType(); <span class="comment">//添加&#123;&#125;后，可以</span></span><br></pre></td></tr></table></figure><p>有花括号，代表是匿名内部类，没有添加的话就代表一个对象</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java：注解、反射和动态代理</title>
      <link href="/2024/08/18/Java%EF%BC%9A%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2024/08/18/Java%EF%BC%9A%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="注解反射和动态代理"><a href="#注解反射和动态代理" class="headerlink" title="注解反射和动态代理"></a>注解反射和动态代理</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p><strong>注解的作用或者意义是什么？</strong></p><p> 注解本身没有任何含义，单独的注解就是一种或注解，它需要结合其他如反射、插桩等技术才有意义</p><p>Java注解(Annotation)又称Java标注，是JDK1.5引入的一种注解机制。是元数据的一种形式，提供关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有用直接影响</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用<code>@interface</code>自定义注解</p><p>\x7e~~ Java<br>@Retention(RetentionPolicy.ROUTIME) &#x2F;&#x2F;保留时<br>@Target({ElementType.TYPE}) &#x2F;&#x2F;作用目标<br>public @interface Lance {<br>    int a();<br>    String b();<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 元注解</span><br><span class="line"></span><br><span class="line">在定义注解时，注解类也能够使用其他的注解声明。在JDK1.5中提供了**用来对注解类进行注解的注解类，我们称之为meta-annotation(元注解)**。</span><br><span class="line"></span><br><span class="line">声明的注解允许作用于哪些节点使用**`@Target`**声明：</span><br><span class="line"></span><br><span class="line">* `TYPE`</span><br><span class="line">* `FIELD`</span><br><span class="line">* `METHOD`</span><br><span class="line">* `PARAMETER`</span><br><span class="line">* `CONSTRUCTOR`</span><br><span class="line">* `LOCAL_VARIABLE`</span><br><span class="line">* `ANNOTATION_TYPE`</span><br><span class="line">* `PACKAGE`</span><br><span class="line">* `TYPE_PARAMETER`</span><br><span class="line">* `TYPE_USE`</span><br><span class="line">* `MODULE`</span><br><span class="line">* `RECORD_COMPONENT`</span><br><span class="line"></span><br><span class="line">保留级别有**`@Retention`**声明。其中保留级别如下</span><br><span class="line"></span><br><span class="line">* `RetentionPolicy.SOURCE`</span><br><span class="line"></span><br><span class="line">  标记的注解仅保留在源级别，并被编译器忽略</span><br><span class="line"></span><br><span class="line">* `RetentionPolicy.CLASS`</span><br><span class="line"></span><br><span class="line">  标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略 </span><br><span class="line"></span><br><span class="line">* `Retention.RUNTIME`</span><br><span class="line"></span><br><span class="line">  标记的注解由JVM保留，因此运行时环境可以使用它</span><br><span class="line"></span><br><span class="line">SOURCE\&lt;CLASS\&lt;ROUTIME, 即CLASS包含了SOURCE， ROUTIME包含SOURCE、CLASS&gt;</span><br><span class="line"></span><br><span class="line">**注意：** </span><br><span class="line"></span><br><span class="line">**CLASS级别的注解保留到class，会被jvm抛弃，但在Android中运行的是dex、class级别注解会被抛弃，runtime注解也和Java一样，被虚拟机识别解析** </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实际应用场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 注解的应用场景</span><br><span class="line"></span><br><span class="line">根据注解的保留级别不同，对注解的使用自然存在不同场景。**由注解的三个不同保留级别可知，注解作用于：源码、字节码、运行时，以下是一些案例**</span><br><span class="line"></span><br><span class="line">| 级别   | 技术       | 使用场景                                                     |</span><br><span class="line">| ------ | ---------- | ------------------------------------------------------------ |</span><br><span class="line">| 源码   | APT        | 在编译期能够获取注解与注解声明的类包括类中所有成员的信息，一般用于生成额外的辅助类 |</span><br><span class="line">| 字节码 | 字节码增强 | 在编译出Class后，通过修改Class数据以实现修改代码逻辑目的。对于是否需要修改的区分或者修改为不同逻辑的判断可以使用注解 |</span><br><span class="line">| 运行时 | 反射       | 在程序运行期间，通过反射技术动态或者注解与其元素，从而完成不同的逻辑判定 |</span><br><span class="line"></span><br><span class="line">###### 限制参数取值范围</span><br><span class="line"></span><br><span class="line">使用枚举的缺点：每个值都会编译成一个对象(对象占用内存运算：对象头 + 实际数据 + 对齐)，更耗内存</span><br><span class="line"></span><br><span class="line">自定义注解：又可以节省内存，又可以限制入参</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## APT注解处理器</span><br><span class="line"></span><br><span class="line">(annotation processor tools)注解处理器</span><br><span class="line"></span><br><span class="line">**注意：**</span><br><span class="line"></span><br><span class="line">* 常用的第三方库中应用：glide arouter butterknife ann hilt...</span><br><span class="line"></span><br><span class="line">* `-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...]` </span><br><span class="line"></span><br><span class="line">  要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line"></span><br><span class="line">* `javac -procerssor apt.jar xxx.java` </span><br><span class="line"></span><br><span class="line">  apt其实就可以看成javac的一个插件</span><br><span class="line"></span><br><span class="line">* `-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...]` </span><br><span class="line"></span><br><span class="line">  要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line"></span><br><span class="line">* apt：不会打包进入APK，只会在编译时参与编译</span><br><span class="line"></span><br><span class="line">##### 自己实现APT</span><br><span class="line"></span><br><span class="line">创建模块</span><br><span class="line"></span><br><span class="line">![image-20231104140619388](https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104140619388.png)</span><br><span class="line"></span><br><span class="line">添加依赖</span><br><span class="line"></span><br><span class="line">![image-20231104140701415](https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104140701415.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：创建的是Java模块，而不是Android模块，Android模块不能给Java模块依赖</span><br><span class="line"></span><br><span class="line">###### 创建注解类</span><br><span class="line"></span><br><span class="line">在annotation模块中创建注解：</span><br><span class="line"></span><br><span class="line">![image-20231104140852713](https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104140852713.png)</span><br><span class="line"></span><br><span class="line">~~~ java</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface MyClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建实现类"><a href="#创建实现类" class="headerlink" title="创建实现类"></a>创建实现类</h6><p>在compile模块下创建注解处理器的实现类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessor</span> <span class="title">extends</span> <span class="title">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean process(Set&lt;? extends TypeElement&gt; <span class="keyword">set</span>, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>process</code>方法，由javac调用，写什么代码就做什么事情</p><h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><ul><li><p>在compile模块的main文件夹下创建：resource -&gt; META-INF -&gt; services -&gt; javax.annotation.prrocessing.Processor中进行注册</p></li><li><p>写上APT实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.wuliner.compile.TestProcessor</span><br></pre></td></tr></table></figure></li></ul><h6 id="配置允许APT处理的注解"><a href="#配置允许APT处理的注解" class="headerlink" title="配置允许APT处理的注解"></a>配置允许APT处理的注解</h6><p>以下两种方法选一种就可以了</p><ul><li>重写该实现类的<code>getSuppotedAnnotationTypes</code>方法</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许此注解处理器处理的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>@SupportedAnnotationTypes()注解</code></p><p>括号中写注解类的全类名,如<code>@SupportedAnnotationTypes(&#123;&quot;com.wuliner.annotation.MyClass&quot;&#125;)</code></p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;<span class="string">&quot;com.wuliner.annotation.MyClass&quot;</span>&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CwProcessor</span> <span class="title">extends</span> <span class="title">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean process(Set&lt;? extends TypeElement&gt; <span class="keyword">set</span>, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Messager messager = processingEnv.getMessager();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;=========&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="引入APT所在模块"><a href="#引入APT所在模块" class="headerlink" title="引入APT所在模块"></a>引入APT所在模块</h6><p>在<code>build.gradle</code></p><ul><li><p><strong>Java</strong>中使用<code>annotationProcessor</code>，如<code>annotationProcessor project(&#39;compiler&#39;)</code></p></li><li><p><strong>kolin</strong>中使用kapt</p></li></ul><p><strong>注意：</strong>apt不会打包进入APK，只会在编译时参与编译</p><h6 id="APT的使用"><a href="#APT的使用" class="headerlink" title="APT的使用"></a>APT的使用</h6><ol><li><p>在类名前添加注解，如<code>@MyClass</code></p></li><li><p>在Processor实现类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;&quot;com.wuliner.annotation.MyClass&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CwProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * javac 调用此方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnvironment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;</span><br><span class="line">        <span class="comment">//写什么代码就做什么事情</span></span><br><span class="line">        <span class="comment">//process：javac编译时的一个回调</span></span><br><span class="line">        <span class="type">Messager</span> <span class="variable">messager</span> <span class="operator">=</span> processingEnv.getMessager();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;=========&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许此注解处理器处理的注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span></span><br><span class="line"><span class="comment">//        return super.getSupportedAnnotationTypes();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><strong>使用Message打印日志：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Messager</span> <span class="variable">messager</span> <span class="operator">=</span> processingEnv.getMessager();</span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line">messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;=========&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="引入注解模块"><a href="#引入注解模块" class="headerlink" title="引入注解模块"></a>引入注解模块</h5><p>使用<code>annotationProcessor</code>引入注解处理器模块, 若使用kotlin，则使用<code>kapt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotationProcessor(project(<span class="string">&quot;:compile&quot;</span>))</span><br></pre></td></tr></table></figure><p>apt不会打包进入apk，只会在编译时参与编译</p><p>在Build窗口中查看日志</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20230911091721939.png" alt="image-20230911091721939"></p><h5 id="为什么APT中process方法会执行多次？"><a href="#为什么APT中process方法会执行多次？" class="headerlink" title="为什么APT中process方法会执行多次？"></a>为什么APT中process方法会执行多次？</h5><p>Java将源码编译成class文件的过程：</p><p><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231104151347259.png" alt="Java将源码编译为class文件的过程"></p><p>java编译过程:词法分析、语法分析、填充符号表、注解处理器处理注解、语义分析、解语法糖、生成字节码。</p><p>注解处理器可以增删改抽象语法树的任意元素。执行到注解处理器，都会重新执行词法分析、语法分析、填充符号表步，直到注解处理器不再对语法树进行修改为止，每一次的循环过程都称为一次Round。</p><p>process第一个参数set集合是要处理的注解集合，如果这个集合为null了，就不需要处理了。写代码就这样去做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!set.isEmpty())&#123;</span><br><span class="line"><span class="comment">//…执行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者通过<code>roundEnvironment.processingOver()</code>将round结束</p></li></ol><h2 id="字节码增强-插桩"><a href="#字节码增强-插桩" class="headerlink" title="字节码增强(插桩)"></a>字节码增强(插桩)</h2><p>字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。</p><p>此外，我们平时使用的动态代理、AOP也于字节码增强密切相关，它们实质上还是利用各种手段生成或修改符合规范的字节码文件。</p><p>综上所述，掌握字节码增强后可以高效的定位并快速修复一些棘手的问题(如线上性能问题，方法出现不可控的出入参需要紧急加日志等问题),也可以在开发中减少冗余代码，大大提高开发效率</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射实现findViewById"><a href="#反射实现findViewById" class="headerlink" title="反射实现findViewById"></a>反射实现<code>findViewById</code></h3><h5 id="通过反射获取类的成员"><a href="#通过反射获取类的成员" class="headerlink" title="通过反射获取类的成员"></a>通过反射获取类的成员</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">injectView</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; cls = acctivity.getClass();</span><br><span class="line">  <span class="comment">//获得此类所有的成员</span></span><br><span class="line">  Filed[] declaredFields = cls.getDeclaredFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><code>Filed</code></p><p>获得自己+父类的成员(不包括private，只能是public)</p></li><li><p><code>DecleredFile</code></p><p>只能获得自己的成员(不包括父类,所有作用域)</p></li></ul><p>可以通过<code>getSuperClass()</code>获取父类的class文件</p><h5 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h5><p>创建注解用来标识，用于筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectView &#123;</span><br><span class="line">  <span class="meta">@IdRes</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要标识的属性上使用注解</p><p>这一传入了<code>TextView</code>对应的id，用来实现<code>findViewById</code>的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectView(R.id.tv)</span></span><br><span class="line"><span class="keyword">private</span> TextView tv;</span><br></pre></td></tr></table></figure><h5 id="筛选Field"><a href="#筛选Field" class="headerlink" title="筛选Field"></a>筛选Field</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InjectUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">injectView</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; cls = activity.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得此类所有的成员</span></span><br><span class="line">        Field[] declaredFields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field filed : declaredFields) &#123;</span><br><span class="line">            <span class="comment">// 判断属性是否被InjectView注解声明</span></span><br><span class="line">            <span class="keyword">if</span> (filed.isAnnotationPresent(InjectView.class)) &#123;</span><br><span class="line">                <span class="type">InjectView</span> <span class="variable">injectView</span> <span class="operator">=</span> filed.getAnnotation(InjectView.class);</span><br><span class="line">                <span class="comment">//获得了注解中设置的id</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> injectView.value();</span><br><span class="line">                <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> activity.findViewById(id);</span><br><span class="line">                <span class="comment">//反射设置 属性的值</span></span><br><span class="line">                filed.setAccessible(<span class="literal">true</span>); <span class="comment">//设置访问权限，允许操作private的属性</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//反射赋值</span></span><br><span class="line">                    filed.set(activity, view);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>先通过<code>Filed</code>的<code>isAnnotationPresent()</code>方法，传入自定义注解的class文件用来判断属性是否被InjectView注解声明</p></li><li><p>再通过<code>getAnnotation()</code>方法，传入注解的class文件，获得对应的注解类</p></li><li><p>再通过这个类获取对应的属性，获得注解中设置的id后，获取对应的View</p></li><li><p>然后通过反射设置属性的值</p><p>先用<code>filed.setAccessible(true)</code>设置访问权限，允许操作private的属性</p><p>通过<code>filed.set(activity, view)</code>，将TextView值设置为对应的View</p></li></ul><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><img src="https://blog-img-bitebyte.oss-cn-chengdu.aliyuncs.com/img/image-20231118140800129.png" alt="image-20231118140800129" style="zoom:80%;" /><h3 id="通过反射获取泛型的真实类型"><a href="#通过反射获取泛型的真实类型" class="headerlink" title="通过反射获取泛型的真实类型"></a>通过反射获取泛型的真实类型</h3><h4 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h4><ul><li><p><code>TypeVariable</code></p><p>泛型类型变量。可以泛型上下限等信息</p></li><li><p><code>ParameterType</code></p><p>具体的泛型类型，可以获得元数据中泛型签名类型(泛型真实类型)</p></li><li><p><code>GenericArrayType</code></p><p>当需要描述的类型是泛型类的数据时，比如List[],Map[],此接口会作为Type的实现</p></li><li><p><code>WildcardType</code></p><p>通配符泛型，获得上下限信息</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeRefrence</span>&lt;Response&lt;Data&gt;&gt;().getType(); <span class="comment">//不行正常运行</span></span><br><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeRefrence</span>&lt;Response&lt;Data&gt;&gt;()&#123;&#125;.getType(); <span class="comment">//添加&#123;&#125;后，可以</span></span><br></pre></td></tr></table></figure><p>有花括号，代表是匿名内部类，没有添加的话就代表一个对象</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/18/hello-world/"/>
      <url>/2024/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
